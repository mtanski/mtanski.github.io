---
published: false
title: JIT code generation in DBKit
layout: post
tags: [DBKit, Rust, SIMD, LLVM, JIT]
---
When I started working on the query engine in [DBKit](https://github.com/mtanski/dbkit) I knew I wanted to build a really fast query engine that could run on the host CPU. Ideally, it would be also able to offload work to GPU or other CoProcessors like the Xeon Phi. In the columnar execution engine this essentially means SIMD or vectorized code. I knew this was going to be a big undertaking. I've previously worked with and hacked Google's [Supersonic](https://github.com/google/supersonic) which my project takes inspiration from and Supersonic it self had limited SIMD support. Supersonic implemented a few expression but it primarily on the C++ compiler generate good code using (using up to SSE4 support). It was also painfully aware that Rust's SIMD support is currently in flux... it's not non-existent but also there's not a story there yet. A little false optimism upfront is not always a bad thing. So in the grand tradition of that  I started on basic plumbing (allocator, schema, collections) and getting first operation working. 

Learning Rust and getting the plumbing working provided enough distraction for a few weeks. After getting that working it was time to implement the FILTER operation and you can't really implement that without being able to supporting enough expressions that you can filter on. Initially I played around with implementing some simple expressions like IsNull, NotNull, Equals, NotEquals, etc... using the raw SIMD instincts. But then 1. I remembered how painful writing SIMD code by hand was 2. being forces to limit how far we can take it by compile time codegen (up SSE2 by default in x86-64) 3. wanting to support SSE2, AVX2, AVX512 and then then GPUs. Confronted with that I took a step back and remember the body of academic research around JITing WHERE expression to avoid per row 2nd level conditional operation  (conditional about the conditional). 

Since the engine is columnar it leads to vectorization so in most cases we're not working with row by row level, but the idea of JIT per column (type) code is something I could run with. Originally I 